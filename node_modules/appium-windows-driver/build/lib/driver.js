"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowsDriver = void 0;
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const support_1 = require("appium/support");
const winappdriver_1 = require("./winappdriver");
const desired_caps_1 = require("./desired-caps");
const appManagementCommands = __importStar(require("./commands/app-management"));
const clipboardCommands = __importStar(require("./commands/clipboard"));
const executeCommands = __importStar(require("./commands/execute"));
const fileCommands = __importStar(require("./commands/file-movement"));
const findCommands = __importStar(require("./commands/find"));
const generalCommands = __importStar(require("./commands/general"));
const gestureCommands = __importStar(require("./commands/gestures"));
const powershellCommands = __importStar(require("./commands/powershell"));
const recordScreenCommands = __importStar(require("./commands/record-screen"));
const touchCommands = __importStar(require("./commands/touch"));
const contextCommands = __importStar(require("./commands/context"));
const logCommands = __importStar(require("./commands/log"));
const constants_1 = require("./constants");
const method_map_1 = require("./method-map");
const execute_method_map_1 = require("./execute-method-map");
/** @type {import('@appium/types').RouteMatcher[]} */
const NO_PROXY = [
    ['GET', new RegExp('^/session/[^/]+/appium/(?!app/)[^/]+')],
    ['POST', new RegExp('^/session/[^/]+/appium/(?!app/)[^/]+')],
    ['POST', new RegExp('^/session/[^/]+/element/[^/]+/elements?$')],
    ['POST', new RegExp('^/session/[^/]+/elements?$')],
    ['POST', new RegExp('^/session/[^/]+/execute')],
    ['POST', new RegExp('^/session/[^/]+/execute/sync')],
    ['POST', new RegExp('^/session/[^/]+/appium/device/push_file')],
    ['POST', new RegExp('^/session/[^/]+/appium/device/pull_file')],
    ['POST', new RegExp('^/session/[^/]+/appium/device/pull_folder')],
    ['GET', new RegExp('^/session/[^/]+/screenshot')],
    ['GET', new RegExp('^/session/[^/]+/contexts?')],
    ['POST', new RegExp('^/session/[^/]+/context')],
    ['GET', new RegExp('^/session/[^/]+/log/types')],
    ['POST', new RegExp('^/session/[^/]+/log')],
    ['GET', new RegExp('^/session/[^/]+/se/log/types')],
    ['POST', new RegExp('^/session/[^/]+/se/log')],
    // Workarounds for
    // - https://github.com/appium/appium/issues/15923
    // - https://github.com/appium/appium/issues/16316
    // TODO: Remove it after WAD properly supports W3C
    ['GET', new RegExp('^/session/[^/]+/element/[^/]+/rect')],
    ['POST', new RegExp('^/session/[^/]+/window/rect')],
    ['GET', new RegExp('^/session/[^/]+/window/rect')],
    // end workaround
];
// Appium instantiates this class
/**
 * @implements {ExternalDriver<WindowsDriverConstraints, string>}
 * @extends {BaseDriver<WindowsDriverConstraints>}
 */
class WindowsDriver extends driver_1.BaseDriver {
    /** @type {boolean} */
    isProxyActive;
    /** @type {import('@appium/types').RouteMatcher[]} */
    jwpProxyAvoid;
    /** @type {WinAppDriver} */
    winAppDriver;
    /** @type {import('./commands/record-screen').ScreenRecorder | null} */
    _screenRecorder;
    static newMethodMap = method_map_1.newMethodMap;
    static executeMethodMap = execute_method_map_1.executeMethodMap;
    constructor(opts = {}, shouldValidateCaps = true) {
        // @ts-ignore TODO: Make opts typed
        super(opts, shouldValidateCaps);
        this.desiredCapConstraints = desired_caps_1.desiredCapConstraints;
        this.locatorStrategies = [
            'xpath',
            'id',
            'name',
            'tag name',
            'class name',
            'accessibility id',
        ];
        this.resetState();
    }
    resetState() {
        this.jwpProxyAvoid = NO_PROXY;
        this.isProxyActive = false;
        // @ts-ignore It's ok
        this.winAppDriver = null;
        this._screenRecorder = null;
    }
    // @ts-ignore TODO: Make args typed
    async createSession(...args) {
        if (!support_1.system.isWindows()) {
            throw new Error('WinAppDriver tests only run on Windows');
        }
        try {
            // @ts-ignore TODO: Make args typed
            const [sessionId, caps] = await super.createSession(...args);
            if (caps.prerun) {
                this.log.info('Executing prerun PowerShell script');
                if (!lodash_1.default.isString(caps.prerun.command) && !lodash_1.default.isString(caps.prerun.script)) {
                    throw new Error(`'prerun' capability value must either contain ` +
                        `'script' or 'command' entry of string type`);
                }
                this.assertFeatureEnabled(constants_1.POWER_SHELL_FEATURE);
                const output = await this.execPowerShell(caps.prerun);
                if (output) {
                    this.log.info(`Prerun script output: ${output}`);
                }
            }
            await this.startWinAppDriverSession();
            return [sessionId, caps];
        }
        catch (e) {
            await this.deleteSession();
            throw e;
        }
    }
    async startWinAppDriverSession() {
        this.winAppDriver = new winappdriver_1.WinAppDriver(this.log, {
            url: this.opts.wadUrl,
            port: this.opts.systemPort,
            reqBasePath: this.basePath,
        });
        await this.winAppDriver.start(this.caps);
        this.proxyReqRes = this.winAppDriver.proxy?.proxyReqRes.bind(this.winAppDriver.proxy);
        // now that everything has started successfully, turn on proxying so all
        // subsequent session requests go straight to/from WinAppDriver
        this.isProxyActive = true;
    }
    async deleteSession() {
        this.log.debug('Deleting WinAppDriver session');
        await this._screenRecorder?.stop(true);
        await this.winAppDriver?.stop();
        if (this.opts.postrun) {
            if (!lodash_1.default.isString(this.opts.postrun.command) && !lodash_1.default.isString(this.opts.postrun.script)) {
                this.log.error(`'postrun' capability value must either contain ` +
                    `'script' or 'command' entry of string type`);
            }
            else {
                this.log.info('Executing postrun PowerShell script');
                try {
                    this.assertFeatureEnabled(constants_1.POWER_SHELL_FEATURE);
                    const output = await this.execPowerShell(this.opts.postrun);
                    if (output) {
                        this.log.info(`Postrun script output: ${output}`);
                    }
                }
                catch (e) {
                    this.log.error(e.message);
                }
            }
        }
        this.resetState();
        await super.deleteSession();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    proxyActive(sessionId) {
        return this.isProxyActive;
    }
    canProxy() {
        // we can always proxy to the WinAppDriver server
        return true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getProxyAvoidList(sessionId) {
        return this.jwpProxyAvoid;
    }
    async proxyCommand(url, method, body) {
        if (!this.winAppDriver?.proxy) {
            throw new Error('The proxy must be defined in order to send commands');
        }
        return /** @type {any} */ (await this.winAppDriver.proxy.command(url, method, body));
    }
    windowsLaunchApp = appManagementCommands.windowsLaunchApp;
    windowsCloseApp = appManagementCommands.windowsCloseApp;
    windowsSetClipboard = clipboardCommands.windowsSetClipboard;
    windowsGetClipboard = clipboardCommands.windowsGetClipboard;
    execute = executeCommands.execute;
    pushFile = fileCommands.pushFile;
    pullFile = fileCommands.pullFile;
    pullFolder = fileCommands.pullFolder;
    windowsDeleteFile = fileCommands.windowsDeleteFile;
    windowsDeleteFolder = fileCommands.windowsDeleteFolder;
    // @ts-ignore This is expected
    findElOrEls = findCommands.findElOrEls;
    getWindowSize = generalCommands.getWindowSize;
    getWindowRect = generalCommands.getWindowRect;
    setWindowRect = generalCommands.setWindowRect;
    getScreenshot = generalCommands.getScreenshot;
    getElementRect = generalCommands.getElementRect;
    windowsClick = gestureCommands.windowsClick;
    windowsScroll = gestureCommands.windowsScroll;
    windowsClickAndDrag = gestureCommands.windowsClickAndDrag;
    windowsHover = gestureCommands.windowsHover;
    windowsKeys = gestureCommands.windowsKeys;
    execPowerShell = powershellCommands.execPowerShell;
    windowsStartRecordingScreen = recordScreenCommands.windowsStartRecordingScreen;
    windowsStopRecordingScreen = recordScreenCommands.windowsStopRecordingScreen;
    startRecordingScreen = recordScreenCommands.startRecordingScreen;
    stopRecordingScreen = recordScreenCommands.stopRecordingScreen;
    performActions = touchCommands.performActions;
    getContexts = contextCommands.getContexts;
    getCurrentContext = contextCommands.getCurrentContext;
    setContext = contextCommands.setContext;
    supportedLogTypes = logCommands.supportedLogTypes;
}
exports.WindowsDriver = WindowsDriver;
exports.default = WindowsDriver;
/**
 * @typedef {typeof desiredCapConstraints} WindowsDriverConstraints
 * @typedef {import('@appium/types').DriverOpts<WindowsDriverConstraints>} WindowsDriverOpts
 */
/**
 * @template {import('@appium/types').Constraints} C
 * @template [Ctx=string]
 * @typedef {import('@appium/types').ExternalDriver<C, Ctx>} ExternalDriver
 */
//# sourceMappingURL=driver.js.map