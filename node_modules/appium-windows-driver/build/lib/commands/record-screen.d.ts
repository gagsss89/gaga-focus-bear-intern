/**
 * Record the display in background while the automated test is running.
 * This method requires FFMPEG (https://www.ffmpeg.org/download.html) to be installed
 * and present in PATH.
 * The resulting video uses H264 codec and is ready to be played by media players built-in into web browsers.
 *
 * @this {WindowsDriver}
 * @param {string} [videoFilter] - The video filter spec to apply for ffmpeg.
 * See https://trac.ffmpeg.org/wiki/FilteringGuide for more details on the possible values.
 * Example: Set it to `scale=ifnot(gte(iw\,1024)\,iw\,1024):-2` in order to limit the video width
 * to 1024px. The height will be adjusted automatically to match the actual ratio.
 * @param {number|string} [fps=15] - The count of frames per second in the resulting video.
 * The greater fps it has the bigger file size is.
 * @param {string} [preset='veryfast'] - One of the supported encoding presets. Possible values are:
 * - ultrafast
 * - superfast
 * - veryfast
 * - faster
 * - fast
 * - medium
 * - slow
 * - slower
 * - veryslow
 * A preset is a collection of options that will provide a certain encoding speed to compression ratio.
 * A slower preset will provide better compression (compression is quality per filesize).
 * This means that, for example, if you target a certain file size or constant bit rate, you will achieve better
 * quality with a slower preset. Read https://trac.ffmpeg.org/wiki/Encode/H.264 for more details.
 * @param {boolean} [captureCursor=false] - Whether to capture the mouse cursor while recording
 * the screen
 * @param {boolean} [captureClicks=false] - Whether to capture mouse clicks while recording the
 * screen
 * @param {string} [audioInput] - If set then the given audio input will be used to record the computer audio
 * along with the desktop video. The list of available devices could be retrieved using
 * `ffmpeg -list_devices true -f dshow -i dummy` command.
 * @param {string|number} [timeLimit=600] - The maximum recording time, in seconds. The default
 * value is 600 seconds (10 minutes).
 * @param {boolean} [forceRestart=true] - Whether to ignore the call if a screen recording is currently running
 * (`false`) or to start a new recording immediately and terminate the existing one if running (`true`).
 * @throws {Error} If screen recording has failed to start or is not supported on the device under test.
 */
export function windowsStartRecordingScreen(this: import("../driver").WindowsDriver, timeLimit?: string | number, videoFilter?: string, fps?: number | string, preset?: string, captureCursor?: boolean, captureClicks?: boolean, audioInput?: string, forceRestart?: boolean): Promise<void>;
export class windowsStartRecordingScreen {
    /**
     * Record the display in background while the automated test is running.
     * This method requires FFMPEG (https://www.ffmpeg.org/download.html) to be installed
     * and present in PATH.
     * The resulting video uses H264 codec and is ready to be played by media players built-in into web browsers.
     *
     * @this {WindowsDriver}
     * @param {string} [videoFilter] - The video filter spec to apply for ffmpeg.
     * See https://trac.ffmpeg.org/wiki/FilteringGuide for more details on the possible values.
     * Example: Set it to `scale=ifnot(gte(iw\,1024)\,iw\,1024):-2` in order to limit the video width
     * to 1024px. The height will be adjusted automatically to match the actual ratio.
     * @param {number|string} [fps=15] - The count of frames per second in the resulting video.
     * The greater fps it has the bigger file size is.
     * @param {string} [preset='veryfast'] - One of the supported encoding presets. Possible values are:
     * - ultrafast
     * - superfast
     * - veryfast
     * - faster
     * - fast
     * - medium
     * - slow
     * - slower
     * - veryslow
     * A preset is a collection of options that will provide a certain encoding speed to compression ratio.
     * A slower preset will provide better compression (compression is quality per filesize).
     * This means that, for example, if you target a certain file size or constant bit rate, you will achieve better
     * quality with a slower preset. Read https://trac.ffmpeg.org/wiki/Encode/H.264 for more details.
     * @param {boolean} [captureCursor=false] - Whether to capture the mouse cursor while recording
     * the screen
     * @param {boolean} [captureClicks=false] - Whether to capture mouse clicks while recording the
     * screen
     * @param {string} [audioInput] - If set then the given audio input will be used to record the computer audio
     * along with the desktop video. The list of available devices could be retrieved using
     * `ffmpeg -list_devices true -f dshow -i dummy` command.
     * @param {string|number} [timeLimit=600] - The maximum recording time, in seconds. The default
     * value is 600 seconds (10 minutes).
     * @param {boolean} [forceRestart=true] - Whether to ignore the call if a screen recording is currently running
     * (`false`) or to start a new recording immediately and terminate the existing one if running (`true`).
     * @throws {Error} If screen recording has failed to start or is not supported on the device under test.
     */
    constructor(this: import("../driver").WindowsDriver, timeLimit?: string | number, videoFilter?: string, fps?: number | string, preset?: string, captureCursor?: boolean, captureClicks?: boolean, audioInput?: string, forceRestart?: boolean);
    _screenRecorder: ScreenRecorder;
}
/**
 * Stop recording the screen.
 * If no screen recording has been started before then the method returns an empty string.
 *
 * @this {WindowsDriver}
 * @param {string} [remotePath] - The path to the remote location, where the resulting video should be uploaded.
 * The following protocols are supported: http/https, ftp.
 * Null or empty string value (the default setting) means the content of resulting
 * file should be encoded as Base64 and passed as the endpoint response value.
 * An exception will be thrown if the generated media file is too big to
 * fit into the available process memory.
 * @param {string} [user] - The name of the user for the remote authentication.
 * @param {string} [pass] - The password for the remote authentication.
 * @param {string} [method] - The http multipart upload method name. The 'PUT' one is used by default.
 * @param {Object} [headers] - Additional headers mapping for multipart http(s) uploads
 * @param {string} [fileFieldName='file'] - The name of the form field, where the file content BLOB should be stored for
 *                                            http(s) uploads
 * @param {Object[]|[string, string][]} [formFields] - Additional form fields for multipart http(s) uploads
 * @returns {Promise<string>} Base64-encoded content of the recorded media file if 'remotePath'
 * parameter is falsy or an empty string.
 * @this {import('../driver').WindowsDriver}
 * @throws {Error} If there was an error while getting the name of a media file
 * or the file content cannot be uploaded to the remote location
 * or screen recording is not supported on the device under test.
 */
export function windowsStopRecordingScreen(this: import("../driver").WindowsDriver, remotePath?: string, user?: string, pass?: string, method?: string, headers?: any, fileFieldName?: string, formFields?: any[] | [string, string][]): Promise<string>;
/**
 * Record the display in background while the automated test is running.
 * This method requires FFMPEG (https://www.ffmpeg.org/download.html) to be installed
 * and present in PATH.
 * The resulting video uses H264 codec and is ready to be played by media players built-in into web browsers.
 *
 * @param {StartRecordingOptions} [options] - The available options.
 * @this {import('../driver').WindowsDriver}
 * @throws {Error} If screen recording has failed to start or is not supported on the device under test.
 */
export function startRecordingScreen(this: import("../driver").WindowsDriver, options?: StartRecordingOptions): Promise<void>;
/**
 * Stop recording the screen.
 * If no screen recording has been started before then the method returns an empty string.
 *
 * @param {StopRecordingOptions} [options] - The available options.
 * @returns {Promise<string>} Base64-encoded content of the recorded media file if 'remotePath'
 * parameter is falsy or an empty string.
 * @this {import('../driver').WindowsDriver}
 * @throws {Error} If there was an error while getting the name of a media file
 * or the file content cannot be uploaded to the remote location
 * or screen recording is not supported on the device under test.
 */
export function stopRecordingScreen(this: import("../driver").WindowsDriver, options?: StopRecordingOptions): Promise<string>;
export class ScreenRecorder {
    /**
     * @param {string} videoPath
     * @param {import('@appium/types').AppiumLogger} log
     * @param {import('@appium/types').StringRecord} opts
     */
    constructor(videoPath: string, log: import("@appium/types").AppiumLogger, opts?: import("@appium/types").StringRecord);
    log: import("@appium/types").AppiumLogger;
    _videoPath: string;
    _process: any;
    _fps: any;
    _audioInput: any;
    _captureCursor: any;
    _captureClicks: any;
    _preset: any;
    _videoFilter: any;
    _timeLimit: any;
    getVideoPath(): Promise<string>;
    isRunning(): boolean;
    _enforceTermination(): Promise<string>;
    start(): Promise<void>;
    stop(force?: boolean): Promise<any>;
}
export type WindowsDriver = import("../driver").WindowsDriver;
/**
 * For detailed explanations of each property,
 * please refer to the parameters of the {@linkcode windowsStartRecordingScreen} function.
 */
export type StartRecordingOptions = {
    videoFilter?: string | undefined;
    fps?: string | number | undefined;
    preset?: string | undefined;
    captureCursor?: boolean | undefined;
    captureClicks?: boolean | undefined;
    audioInput?: string | undefined;
    timeLimit?: string | number | undefined;
    forceRestart?: boolean | undefined;
};
/**
 * For detailed explanations of each property,
 * please refer to the parameters of the {@linkcode windowsStopRecordingScreen} function.
 */
export type StopRecordingOptions = {
    remotePath?: string | undefined;
    user?: string | undefined;
    pass?: string | undefined;
    method?: string | undefined;
    headers?: any;
    fileFieldName?: string | undefined;
    formFields?: any[] | [string, string][] | undefined;
};
//# sourceMappingURL=record-screen.d.ts.map