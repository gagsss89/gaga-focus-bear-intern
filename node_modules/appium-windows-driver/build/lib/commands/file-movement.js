"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pushFile = pushFile;
exports.pullFile = pullFile;
exports.pullFolder = pullFolder;
exports.windowsDeleteFile = windowsDeleteFile;
exports.windowsDeleteFolder = windowsDeleteFolder;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const driver_1 = require("appium/driver");
const support_1 = require("appium/support");
const constants_1 = require("../constants");
// List of env variables, that can be expanded in path
const KNOWN_ENV_VARS = [
    'APPDATA', 'LOCALAPPDATA',
    'PROGRAMFILES', 'PROGRAMFILES(X86)',
    'PROGRAMDATA', 'ALLUSERSPROFILE',
    'TEMP', 'TMP',
    'HOMEPATH', 'USERPROFILE', 'PUBLIC'
];
/**
 *
 * @this {WindowsDriver}
 * @param {string} remotePath
 * @param {string} base64Data
 * @returns {Promise<void>}
 */
async function pushFile(remotePath, base64Data) {
    this.assertFeatureEnabled(constants_1.MODIFY_FS_FEATURE);
    if (remotePath.endsWith(path_1.default.sep)) {
        throw new driver_1.errors.InvalidArgumentError('It is expected that remote path points to a file rather than a folder. ' +
            `'${remotePath}' is given instead`);
    }
    if (lodash_1.default.isArray(base64Data)) {
        // some clients (ahem) java, send a byte array encoding utf8 characters
        // instead of a string, which would be infinitely better!
        base64Data = Buffer.from(base64Data).toString('utf8');
    }
    const fullPath = resolveToAbsolutePath(remotePath);
    await (0, support_1.mkdirp)(path_1.default.dirname(fullPath));
    const content = Buffer.from(base64Data, 'base64');
    await support_1.fs.writeFile(fullPath, content);
}
/**
 *
 * @this {WindowsDriver}
 * @param {string} remotePath
 * @returns {Promise<string>}
 */
async function pullFile(remotePath) {
    const fullPath = resolveToAbsolutePath(remotePath);
    await checkFileExists(fullPath);
    return (await support_1.util.toInMemoryBase64(fullPath)).toString();
}
/**
 *
 * @this {WindowsDriver}
 * @param {string} remotePath
 * @returns {Promise<string>}
 */
async function pullFolder(remotePath) {
    const fullPath = resolveToAbsolutePath(remotePath);
    await checkFolderExists(fullPath);
    return (await support_1.zip.toInMemoryZip(fullPath, {
        encodeToBase64: true,
    })).toString();
}
/**
 * Remove the file from the file system
 *
 * @this {WindowsDriver}
 * @param {string} remotePath - The path to a file.
 * The path may contain environment variables that could be expanded on the server side.
 * Due to security reasons only variables listed below would be expanded: `APPDATA`,
 * `LOCALAPPDATA`, `PROGRAMFILES`, `PROGRAMFILES(X86)`, `PROGRAMDATA`, `ALLUSERSPROFILE`,
 * `TEMP`, `TMP`, `HOMEPATH`, `USERPROFILE`, `PUBLIC`.
 * @throws {InvalidArgumentError} If the file to be deleted does not exist or
 * remote path is not an absolute path.
 */
async function windowsDeleteFile(remotePath) {
    this.assertFeatureEnabled(constants_1.MODIFY_FS_FEATURE);
    const fullPath = resolveToAbsolutePath(remotePath);
    await checkFileExists(fullPath);
    await support_1.fs.unlink(fullPath);
}
/**
 * Remove the folder from the file system
 *
 * @this {WindowsDriver}
 * @param {string} remotePath - The path to a folder.
 * The path may contain environment variables that could be expanded on the server side.
 * Due to security reasons only variables listed below would be expanded: `APPDATA`,
 * `LOCALAPPDATA`, `PROGRAMFILES`, `PROGRAMFILES(X86)`, `PROGRAMDATA`, `ALLUSERSPROFILE`,
 * `TEMP`, `TMP`, `HOMEPATH`, `USERPROFILE`, `PUBLIC`.
 * @throws {InvalidArgumentError} If the folder to be deleted does not exist or
 * remote path is not an absolute path.
 */
async function windowsDeleteFolder(remotePath) {
    this.assertFeatureEnabled(constants_1.MODIFY_FS_FEATURE);
    const fullPath = resolveToAbsolutePath(remotePath);
    await checkFolderExists(fullPath);
    await support_1.fs.rimraf(fullPath);
}
/**
 *
 * @param {string} remotePath
 * @returns {string}
 */
function resolveToAbsolutePath(remotePath) {
    const resolvedPath = remotePath.replace(/%([^%]+)%/g, (_, key) => KNOWN_ENV_VARS.includes(key.toUpperCase())
        ? /** @type {string} */ (process.env[key.toUpperCase()])
        : `%${key}%`);
    if (!path_1.default.isAbsolute(resolvedPath)) {
        throw new driver_1.errors.InvalidArgumentError('It is expected that remote path is absolute. ' +
            `'${resolvedPath}' is given instead`);
    }
    return resolvedPath;
}
/**
 *
 * @param {string} remotePath
 * @returns {Promise<void>}
 */
async function checkFileExists(remotePath) {
    if (!await support_1.fs.exists(remotePath)) {
        throw new driver_1.errors.InvalidArgumentError(`The remote file '${remotePath}' does not exist.`);
    }
    const stat = await support_1.fs.stat(remotePath);
    if (!stat.isFile()) {
        throw new driver_1.errors.InvalidArgumentError('It is expected that remote path points to a file rather than a folder. ' +
            `'${remotePath}' is given instead`);
    }
}
/**
 *
 * @param {string} remotePath
 * @returns {Promise<void>}
 */
async function checkFolderExists(remotePath) {
    if (!await support_1.fs.exists(remotePath)) {
        throw new driver_1.errors.InvalidArgumentError(`The remote folder '${remotePath}' does not exist.`);
    }
    const stat = await support_1.fs.stat(remotePath);
    if (!stat.isDirectory()) {
        throw new driver_1.errors.InvalidArgumentError('It is expected that remote path points to a folder rather than a file. ' +
            `'${remotePath}' is given instead`);
    }
}
/**
 * @typedef {import('../driver').WindowsDriver} WindowsDriver
 */ 
//# sourceMappingURL=file-movement.js.map